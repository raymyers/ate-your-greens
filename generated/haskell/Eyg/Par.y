-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Eyg.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Eyg.Abs
import Eyg.Lex

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('              { PT _ (TS _ 1)              }
  ')'              { PT _ (TS _ 2)              }
  ','              { PT _ (TS _ 3)              }
  '-'              { PT _ (TS _ 4)              }
  '->'             { PT _ (TS _ 5)              }
  '.'              { PT _ (TS _ 6)              }
  '..'             { PT _ (TS _ 7)              }
  ':'              { PT _ (TS _ 8)              }
  ';'              { PT _ (TS _ 9)              }
  '='              { PT _ (TS _ 10)             }
  '['              { PT _ (TS _ 11)             }
  ']'              { PT _ (TS _ 12)             }
  'case'           { PT _ (TS _ 13)             }
  'handle'         { PT _ (TS _ 14)             }
  'let'            { PT _ (TS _ 15)             }
  'match'          { PT _ (TS _ 16)             }
  'perform'        { PT _ (TS _ 17)             }
  '{'              { PT _ (TS _ 18)             }
  '|'              { PT _ (TS _ 19)             }
  '}'              { PT _ (TS _ 20)             }
  L_integ          { PT _ (TI $$)               }
  L_quoted         { PT _ (TL $$)               }
  L_NamedReference { PT _ (T_NamedReference $$) }
  L_Tag            { PT _ (T_Tag $$)            }
  L_Id             { PT _ (T_Id $$)             }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

NamedReference :: { Eyg.Abs.NamedReference }
NamedReference  : L_NamedReference { Eyg.Abs.NamedReference $1 }

Tag :: { Eyg.Abs.Tag }
Tag  : L_Tag { Eyg.Abs.Tag $1 }

Id :: { Eyg.Abs.Id }
Id  : L_Id { Eyg.Abs.Id $1 }

Program :: { Eyg.Abs.Program }
Program : Exp { Eyg.Abs.PExps $1 }

Exp :: { Eyg.Abs.Exp }
Exp : Exp1 { $1 }

Exp1 :: { Eyg.Abs.Exp }
Exp1
  : Exp2 { $1 }
  | 'let' MatchPattern '=' Exp2 ';' Exp { Eyg.Abs.ELet $2 $4 $6 }

Exp2 :: { Eyg.Abs.Exp }
Exp2
  : Exp3 { $1 }
  | '[' ListListItem ']' { Eyg.Abs.EList $2 }
  | '{' ListRecordField '}' { Eyg.Abs.ERecord $2 }
  | Tag Exp { Eyg.Abs.ETagged $1 $2 }
  | '|' ListParam '|' '{' Exp '}' { Eyg.Abs.ELambda $2 $5 }
  | 'perform' Exp2 { Eyg.Abs.EPerform $2 }
  | 'handle' Tag '(' Exp2 ',' Exp2 ')' { Eyg.Abs.EHandle $2 $4 $6 }
  | 'match' Exp2 '{' 'case' ListMatchItem '}' { Eyg.Abs.EMatch $2 $5 }

Exp3 :: { Eyg.Abs.Exp }
Exp3
  : Exp4 { $1 }
  | Exp3 '(' ListExp2 ')' { Eyg.Abs.EApply $1 $3 }
  | Exp3 '.' Id { Eyg.Abs.ESelect $1 $3 }

Exp4 :: { Eyg.Abs.Exp }
Exp4
  : Exp5 { $1 }
  | Id { Eyg.Abs.EVar $1 }
  | Integer { Eyg.Abs.EInt $1 }
  | '-' Integer { Eyg.Abs.ENegInt $2 }
  | String { Eyg.Abs.EString $1 }
  | NamedReference { Eyg.Abs.ENamedReference $1 }

Exp5 :: { Eyg.Abs.Exp }
Exp5 : '(' Exp ')' { $2 }

ListListItem :: { [Eyg.Abs.ListItem] }
ListListItem
  : {- empty -} { [] }
  | ListItem { (:[]) $1 }
  | ListItem ',' ListListItem { (:) $1 $3 }

ListRecordField :: { [Eyg.Abs.RecordField] }
ListRecordField
  : {- empty -} { [] }
  | RecordField { (:[]) $1 }
  | RecordField ',' ListRecordField { (:) $1 $3 }

ListMatchItem :: { [Eyg.Abs.MatchItem] }
ListMatchItem
  : {- empty -} { [] }
  | MatchItem { (:[]) $1 }
  | MatchItem 'case' ListMatchItem { (:) $1 $3 }

ListExp2 :: { [Eyg.Abs.Exp] }
ListExp2
  : {- empty -} { [] }
  | Exp2 { (:[]) $1 }
  | Exp2 ',' ListExp2 { (:) $1 $3 }

ListParam :: { [Eyg.Abs.Param] }
ListParam
  : {- empty -} { [] }
  | Param { (:[]) $1 }
  | Param ',' ListParam { (:) $1 $3 }

MatchItem :: { Eyg.Abs.MatchItem }
MatchItem : MatchPattern '->' Exp { Eyg.Abs.MatchItem0 $1 $3 }

MatchPattern :: { Eyg.Abs.MatchPattern }
MatchPattern
  : Tag MatchPattern { Eyg.Abs.MPTagged $1 $2 }
  | '{' ListRecordField '}' { Eyg.Abs.MPRecord $2 }
  | Id { Eyg.Abs.MPId $1 }
  | '(' MatchPattern ')' { $2 }

RecordField :: { Eyg.Abs.RecordField }
RecordField
  : Id ':' Exp { Eyg.Abs.RFKeyVal $1 $3 }
  | '..' Exp { Eyg.Abs.RFSpread $2 }

Param :: { Eyg.Abs.Param }
Param : Id { Eyg.Abs.PId $1 }

Arg :: { Eyg.Abs.Arg }
Arg : Exp { Eyg.Abs.ArgExpr $1 }

ListItem :: { Eyg.Abs.ListItem }
ListItem
  : Exp { Eyg.Abs.LIExpr $1 } | '..' Exp { Eyg.Abs.LISpread $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

