/* File generated by the BNF Converter (bnfc 2.9.6). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* NamedReference;
typedef char* Tag;
typedef char* Id;

/********************   Forward Declarations    ***********************/
struct Program_;
typedef struct Program_ *Program;

struct Exp_;
typedef struct Exp_ *Exp;

struct ListListItem_;
typedef struct ListListItem_ *ListListItem;

struct ListRecordField_;
typedef struct ListRecordField_ *ListRecordField;

struct ListMatchItem_;
typedef struct ListMatchItem_ *ListMatchItem;

struct ListExp_;
typedef struct ListExp_ *ListExp;

struct ListParam_;
typedef struct ListParam_ *ListParam;

struct MatchItem_;
typedef struct MatchItem_ *MatchItem;

struct MatchPattern_;
typedef struct MatchPattern_ *MatchPattern;

struct RecordField_;
typedef struct RecordField_ *RecordField;

struct Param_;
typedef struct Param_ *Param;

struct ListItem_;
typedef struct ListItem_ *ListItem;

/********************   Abstract Syntax Classes    ********************/

struct Program_
{
  enum { is_PExps } kind;
  union
  {
    struct { Exp exp_; } pExps_;
  } u;
};

Program make_PExps(Exp p0);

struct Exp_
{
  enum { is_ELet, is_EList, is_ERecord, is_ETagged, is_ELambda, is_EPerform, is_EHandle, is_EMatch, is_EApply, is_ESelect, is_EVar, is_EInt, is_ENegInt, is_EString, is_ENamedReference } kind;
  union
  {
    struct { Exp exp_1, exp_2; MatchPattern matchpattern_; } eLet_;
    struct { ListListItem listlistitem_; } eList_;
    struct { ListRecordField listrecordfield_; } eRecord_;
    struct { Exp exp_; Tag tag_; } eTagged_;
    struct { Exp exp_; ListParam listparam_; } eLambda_;
    struct { Exp exp_; } ePerform_;
    struct { Exp exp_1, exp_2; Tag tag_; } eHandle_;
    struct { Exp exp_; ListMatchItem listmatchitem_; } eMatch_;
    struct { Exp exp_; ListExp listexp_; } eApply_;
    struct { Exp exp_; Id id_; } eSelect_;
    struct { Id id_; } eVar_;
    struct { Integer integer_; } eInt_;
    struct { Integer integer_; } eNegInt_;
    struct { String string_; } eString_;
    struct { NamedReference namedreference_; } eNamedReference_;
  } u;
};

Exp make_ELet(MatchPattern p0, Exp p1, Exp p2);
Exp make_EList(ListListItem p0);
Exp make_ERecord(ListRecordField p0);
Exp make_ETagged(Tag p0, Exp p1);
Exp make_ELambda(ListParam p0, Exp p1);
Exp make_EPerform(Exp p0);
Exp make_EHandle(Tag p0, Exp p1, Exp p2);
Exp make_EMatch(Exp p0, ListMatchItem p1);
Exp make_EApply(Exp p0, ListExp p1);
Exp make_ESelect(Exp p0, Id p1);
Exp make_EVar(Id p0);
Exp make_EInt(Integer p0);
Exp make_ENegInt(Integer p0);
Exp make_EString(String p0);
Exp make_ENamedReference(NamedReference p0);

struct ListListItem_
{
  ListItem listitem_;
  ListListItem listlistitem_;
};

ListListItem make_ListListItem(ListItem p1, ListListItem p2);

struct ListRecordField_
{
  RecordField recordfield_;
  ListRecordField listrecordfield_;
};

ListRecordField make_ListRecordField(RecordField p1, ListRecordField p2);

struct ListMatchItem_
{
  MatchItem matchitem_;
  ListMatchItem listmatchitem_;
};

ListMatchItem make_ListMatchItem(MatchItem p1, ListMatchItem p2);

struct ListExp_
{
  Exp exp_;
  ListExp listexp_;
};

ListExp make_ListExp(Exp p1, ListExp p2);

struct ListParam_
{
  Param param_;
  ListParam listparam_;
};

ListParam make_ListParam(Param p1, ListParam p2);

struct MatchItem_
{
  enum { is_MatchItem0 } kind;
  union
  {
    struct { Exp exp_; MatchPattern matchpattern_; } matchItem0_;
  } u;
};

MatchItem make_MatchItem0(MatchPattern p0, Exp p1);

struct MatchPattern_
{
  enum { is_MPTagged, is_MPRecord, is_MPId } kind;
  union
  {
    struct { MatchPattern matchpattern_; Tag tag_; } mPTagged_;
    struct { ListRecordField listrecordfield_; } mPRecord_;
    struct { Id id_; } mPId_;
  } u;
};

MatchPattern make_MPTagged(Tag p0, MatchPattern p1);
MatchPattern make_MPRecord(ListRecordField p0);
MatchPattern make_MPId(Id p0);

struct RecordField_
{
  enum { is_RFKeyVal, is_RFSpread } kind;
  union
  {
    struct { Exp exp_; Id id_; } rFKeyVal_;
    struct { Exp exp_; } rFSpread_;
  } u;
};

RecordField make_RFKeyVal(Id p0, Exp p1);
RecordField make_RFSpread(Exp p0);

struct Param_
{
  enum { is_PId } kind;
  union
  {
    struct { Id id_; } pId_;
  } u;
};

Param make_PId(Id p0);

struct ListItem_
{
  enum { is_LIExpr, is_LISpread } kind;
  union
  {
    struct { Exp exp_; } lIExpr_;
    struct { Exp exp_; } lISpread_;
  } u;
};

ListItem make_LIExpr(Exp p0);
ListItem make_LISpread(Exp p0);

/***************************   Cloning   ******************************/

Program clone_Program(Program p);
Exp clone_Exp(Exp p);
ListListItem clone_ListListItem(ListListItem p);
ListRecordField clone_ListRecordField(ListRecordField p);
ListMatchItem clone_ListMatchItem(ListMatchItem p);
ListExp clone_ListExp(ListExp p);
ListParam clone_ListParam(ListParam p);
MatchItem clone_MatchItem(MatchItem p);
MatchPattern clone_MatchPattern(MatchPattern p);
RecordField clone_RecordField(RecordField p);
Param clone_Param(Param p);
ListItem clone_ListItem(ListItem p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Program(Program p);
void free_Exp(Exp p);
void free_ListListItem(ListListItem p);
void free_ListRecordField(ListRecordField p);
void free_ListMatchItem(ListMatchItem p);
void free_ListExp(ListExp p);
void free_ListParam(ListParam p);
void free_MatchItem(MatchItem p);
void free_MatchPattern(MatchPattern p);
void free_RecordField(RecordField p);
void free_Param(Param p);
void free_ListItem(ListItem p);


#endif
