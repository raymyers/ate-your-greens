/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.6). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the eyg_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE eyg__scan_string(const char *str, yyscan_t scanner);
extern void eyg__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void eyg_lex_destroy(yyscan_t scanner);
extern char* eyg_get_text(yyscan_t scanner);

extern yyscan_t eyg__initialize_lexer(FILE * inp);

/* List reversal functions. */
ListListItem reverseListListItem(ListListItem l)
{
  ListListItem prev = 0;
  ListListItem tmp = 0;
  while (l)
  {
    tmp = l->listlistitem_;
    l->listlistitem_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListRecordField reverseListRecordField(ListRecordField l)
{
  ListRecordField prev = 0;
  ListRecordField tmp = 0;
  while (l)
  {
    tmp = l->listrecordfield_;
    l->listrecordfield_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListMatchItem reverseListMatchItem(ListMatchItem l)
{
  ListMatchItem prev = 0;
  ListMatchItem tmp = 0;
  while (l)
  {
    tmp = l->listmatchitem_;
    l->listmatchitem_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListExp reverseListExp(ListExp l)
{
  ListExp prev = 0;
  ListExp tmp = 0;
  while (l)
  {
    tmp = l->listexp_;
    l->listexp_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListParam reverseListParam(ListParam l)
{
  ListParam prev = 0;
  ListParam tmp = 0;
  while (l)
  {
    tmp = l->listparam_;
    l->listparam_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Program program_;
  Exp exp_;
  ListListItem listlistitem_;
  ListRecordField listrecordfield_;
  ListMatchItem listmatchitem_;
  ListExp listexp_;
  ListParam listparam_;
  MatchItem matchitem_;
  MatchPattern matchpattern_;
  RecordField recordfield_;
  Param param_;
  ListItem listitem_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, eyg_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN           /* ( */
%token          _RPAREN           /* ) */
%token          _COMMA            /* , */
%token          _MINUS            /* - */
%token          _RARROW           /* -> */
%token          _DOT              /* . */
%token          _DDOT             /* .. */
%token          _COLON            /* : */
%token          _SEMI             /* ; */
%token          _EQ               /* = */
%token          _LBRACK           /* [ */
%token          _RBRACK           /* ] */
%token          _KW_case          /* case */
%token          _KW_handle        /* handle */
%token          _KW_let           /* let */
%token          _KW_match         /* match */
%token          _KW_perform       /* perform */
%token          _LBRACE           /* { */
%token          _BAR              /* | */
%token          _RBRACE           /* } */
%token<_string> T_Id              /* Id */
%token<_string> T_NamedReference  /* NamedReference */
%token<_string> T_Tag             /* Tag */
%token<_string> _STRING_
%token<_int>    _INTEGER_

%type <program_> Program
%type <exp_> Exp
%type <exp_> Exp1
%type <exp_> Exp2
%type <exp_> Exp3
%type <exp_> Exp4
%type <exp_> Exp5
%type <listlistitem_> ListListItem
%type <listrecordfield_> ListRecordField
%type <listmatchitem_> ListMatchItem
%type <listexp_> ListExp2
%type <listparam_> ListParam
%type <matchitem_> MatchItem
%type <matchpattern_> MatchPattern
%type <recordfield_> RecordField
%type <param_> Param
%type <listitem_> ListItem

%start Program

%%

Program : Exp { $$ = make_PExps($1); result->program_ = $$; }
;
Exp : Exp1 { $$ = $1; }
;
Exp1 : Exp2 { $$ = $1; }
  | _KW_let MatchPattern _EQ Exp2 _SEMI Exp { $$ = make_ELet($2, $4, $6); }
;
Exp2 : Exp3 { $$ = $1; }
  | _LBRACK ListListItem _RBRACK { $$ = make_EList($2); }
  | _LBRACE ListRecordField _RBRACE { $$ = make_ERecord($2); }
  | T_Tag Exp { $$ = make_ETagged($1, $2); }
  | _BAR ListParam _BAR _LBRACE Exp _RBRACE { $$ = make_ELambda($2, $5); }
  | _KW_perform Exp2 { $$ = make_EPerform($2); }
  | _KW_handle T_Tag _LPAREN Exp2 _COMMA Exp2 _RPAREN { $$ = make_EHandle($2, $4, $6); }
  | _KW_match Exp2 _LBRACE _KW_case ListMatchItem _RBRACE { $$ = make_EMatch($2, $5); }
;
Exp3 : Exp4 { $$ = $1; }
  | Exp3 _LPAREN ListExp2 _RPAREN { $$ = make_EApply($1, $3); }
  | Exp3 _DOT T_Id { $$ = make_ESelect($1, $3); }
;
Exp4 : Exp5 { $$ = $1; }
  | T_Id { $$ = make_EVar($1); }
  | _INTEGER_ { $$ = make_EInt($1); }
  | _MINUS _INTEGER_ { $$ = make_ENegInt($2); }
  | _STRING_ { $$ = make_EString($1); }
  | T_NamedReference { $$ = make_ENamedReference($1); }
;
Exp5 : _LPAREN Exp _RPAREN { $$ = $2; }
;
ListListItem : /* empty */ { $$ = 0; }
  | ListItem { $$ = make_ListListItem($1, 0); }
  | ListItem _COMMA ListListItem { $$ = make_ListListItem($1, $3); }
;
ListRecordField : /* empty */ { $$ = 0; }
  | RecordField { $$ = make_ListRecordField($1, 0); }
  | RecordField _COMMA ListRecordField { $$ = make_ListRecordField($1, $3); }
;
ListMatchItem : /* empty */ { $$ = 0; }
  | MatchItem { $$ = make_ListMatchItem($1, 0); }
  | MatchItem _KW_case ListMatchItem { $$ = make_ListMatchItem($1, $3); }
;
ListExp2 : /* empty */ { $$ = 0; }
  | Exp2 { $$ = make_ListExp($1, 0); }
  | Exp2 _COMMA ListExp2 { $$ = make_ListExp($1, $3); }
;
ListParam : /* empty */ { $$ = 0; }
  | Param { $$ = make_ListParam($1, 0); }
  | Param _COMMA ListParam { $$ = make_ListParam($1, $3); }
;
MatchItem : MatchPattern _RARROW Exp { $$ = make_MatchItem0($1, $3); }
;
MatchPattern : T_Tag MatchPattern { $$ = make_MPTagged($1, $2); }
  | _LBRACE ListRecordField _RBRACE { $$ = make_MPRecord($2); }
  | T_Id { $$ = make_MPId($1); }
  | _LPAREN MatchPattern _RPAREN { $$ = $2; }
;
RecordField : T_Id _COLON Exp { $$ = make_RFKeyVal($1, $3); }
  | _DDOT Exp { $$ = make_RFSpread($2); }
;
Param : T_Id { $$ = make_PId($1); }
;
ListItem : Exp { $$ = make_LIExpr($1); }
  | _DDOT Exp { $$ = make_LISpread($2); }
;

%%


/* Entrypoint: parse Program from file. */
Program pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = eyg__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  eyg_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program from string. */
Program psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = eyg__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = eyg__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  eyg__delete_buffer(buf, scanner);
  eyg_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}



