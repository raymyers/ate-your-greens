/* File generated by the BNF Converter (bnfc 2.9.6). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   PExps    ********************/

Program make_PExps(Exp p1)
{
    Program tmp = (Program) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PExps!\n");
        exit(1);
    }
    tmp->kind = is_PExps;
    tmp->u.pExps_.exp_ = p1;
    return tmp;
}

/********************   ELet    ********************/

Exp make_ELet(MatchPattern p1, Exp p2, Exp p3)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ELet!\n");
        exit(1);
    }
    tmp->kind = is_ELet;
    tmp->u.eLet_.matchpattern_ = p1;
    tmp->u.eLet_.exp_1 = p2;
    tmp->u.eLet_.exp_2 = p3;
    return tmp;
}

/********************   EList    ********************/

Exp make_EList(ListListItem p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EList!\n");
        exit(1);
    }
    tmp->kind = is_EList;
    tmp->u.eList_.listlistitem_ = p1;
    return tmp;
}

/********************   ERecord    ********************/

Exp make_ERecord(ListRecordField p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ERecord!\n");
        exit(1);
    }
    tmp->kind = is_ERecord;
    tmp->u.eRecord_.listrecordfield_ = p1;
    return tmp;
}

/********************   ETagged    ********************/

Exp make_ETagged(Tag p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ETagged!\n");
        exit(1);
    }
    tmp->kind = is_ETagged;
    tmp->u.eTagged_.tag_ = p1;
    tmp->u.eTagged_.exp_ = p2;
    return tmp;
}

/********************   ELambda    ********************/

Exp make_ELambda(ListParam p1, Exp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ELambda!\n");
        exit(1);
    }
    tmp->kind = is_ELambda;
    tmp->u.eLambda_.listparam_ = p1;
    tmp->u.eLambda_.exp_ = p2;
    return tmp;
}

/********************   EPerform    ********************/

Exp make_EPerform(Exp p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EPerform!\n");
        exit(1);
    }
    tmp->kind = is_EPerform;
    tmp->u.ePerform_.exp_ = p1;
    return tmp;
}

/********************   EHandle    ********************/

Exp make_EHandle(Tag p1, Exp p2, Exp p3)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EHandle!\n");
        exit(1);
    }
    tmp->kind = is_EHandle;
    tmp->u.eHandle_.tag_ = p1;
    tmp->u.eHandle_.exp_1 = p2;
    tmp->u.eHandle_.exp_2 = p3;
    return tmp;
}

/********************   EMatch    ********************/

Exp make_EMatch(Exp p1, ListMatchItem p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EMatch!\n");
        exit(1);
    }
    tmp->kind = is_EMatch;
    tmp->u.eMatch_.exp_ = p1;
    tmp->u.eMatch_.listmatchitem_ = p2;
    return tmp;
}

/********************   EApply    ********************/

Exp make_EApply(Exp p1, ListExp p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EApply!\n");
        exit(1);
    }
    tmp->kind = is_EApply;
    tmp->u.eApply_.exp_ = p1;
    tmp->u.eApply_.listexp_ = p2;
    return tmp;
}

/********************   ESelect    ********************/

Exp make_ESelect(Exp p1, Id p2)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ESelect!\n");
        exit(1);
    }
    tmp->kind = is_ESelect;
    tmp->u.eSelect_.exp_ = p1;
    tmp->u.eSelect_.id_ = p2;
    return tmp;
}

/********************   EVar    ********************/

Exp make_EVar(Id p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EVar!\n");
        exit(1);
    }
    tmp->kind = is_EVar;
    tmp->u.eVar_.id_ = p1;
    return tmp;
}

/********************   EInt    ********************/

Exp make_EInt(Integer p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EInt!\n");
        exit(1);
    }
    tmp->kind = is_EInt;
    tmp->u.eInt_.integer_ = p1;
    return tmp;
}

/********************   ENegInt    ********************/

Exp make_ENegInt(Integer p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ENegInt!\n");
        exit(1);
    }
    tmp->kind = is_ENegInt;
    tmp->u.eNegInt_.integer_ = p1;
    return tmp;
}

/********************   EString    ********************/

Exp make_EString(String p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EString!\n");
        exit(1);
    }
    tmp->kind = is_EString;
    tmp->u.eString_.string_ = p1;
    return tmp;
}

/********************   ENamedReference    ********************/

Exp make_ENamedReference(NamedReference p1)
{
    Exp tmp = (Exp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ENamedReference!\n");
        exit(1);
    }
    tmp->kind = is_ENamedReference;
    tmp->u.eNamedReference_.namedreference_ = p1;
    return tmp;
}

/********************   ListListItem    ********************/

ListListItem make_ListListItem(ListItem p1, ListListItem p2)
{
    ListListItem tmp = (ListListItem) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListListItem!\n");
        exit(1);
    }
    tmp->listitem_ = p1;
    tmp->listlistitem_ = p2;
    return tmp;
}

/********************   ListRecordField    ********************/

ListRecordField make_ListRecordField(RecordField p1, ListRecordField p2)
{
    ListRecordField tmp = (ListRecordField) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListRecordField!\n");
        exit(1);
    }
    tmp->recordfield_ = p1;
    tmp->listrecordfield_ = p2;
    return tmp;
}

/********************   ListMatchItem    ********************/

ListMatchItem make_ListMatchItem(MatchItem p1, ListMatchItem p2)
{
    ListMatchItem tmp = (ListMatchItem) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListMatchItem!\n");
        exit(1);
    }
    tmp->matchitem_ = p1;
    tmp->listmatchitem_ = p2;
    return tmp;
}

/********************   ListExp    ********************/

ListExp make_ListExp(Exp p1, ListExp p2)
{
    ListExp tmp = (ListExp) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListExp!\n");
        exit(1);
    }
    tmp->exp_ = p1;
    tmp->listexp_ = p2;
    return tmp;
}

/********************   ListParam    ********************/

ListParam make_ListParam(Param p1, ListParam p2)
{
    ListParam tmp = (ListParam) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListParam!\n");
        exit(1);
    }
    tmp->param_ = p1;
    tmp->listparam_ = p2;
    return tmp;
}

/********************   MatchItem0    ********************/

MatchItem make_MatchItem0(MatchPattern p1, Exp p2)
{
    MatchItem tmp = (MatchItem) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MatchItem0!\n");
        exit(1);
    }
    tmp->kind = is_MatchItem0;
    tmp->u.matchItem0_.matchpattern_ = p1;
    tmp->u.matchItem0_.exp_ = p2;
    return tmp;
}

/********************   MPTagged    ********************/

MatchPattern make_MPTagged(Tag p1, MatchPattern p2)
{
    MatchPattern tmp = (MatchPattern) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MPTagged!\n");
        exit(1);
    }
    tmp->kind = is_MPTagged;
    tmp->u.mPTagged_.tag_ = p1;
    tmp->u.mPTagged_.matchpattern_ = p2;
    return tmp;
}

/********************   MPRecord    ********************/

MatchPattern make_MPRecord(ListRecordField p1)
{
    MatchPattern tmp = (MatchPattern) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MPRecord!\n");
        exit(1);
    }
    tmp->kind = is_MPRecord;
    tmp->u.mPRecord_.listrecordfield_ = p1;
    return tmp;
}

/********************   MPId    ********************/

MatchPattern make_MPId(Id p1)
{
    MatchPattern tmp = (MatchPattern) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MPId!\n");
        exit(1);
    }
    tmp->kind = is_MPId;
    tmp->u.mPId_.id_ = p1;
    return tmp;
}

/********************   RFKeyVal    ********************/

RecordField make_RFKeyVal(Id p1, Exp p2)
{
    RecordField tmp = (RecordField) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RFKeyVal!\n");
        exit(1);
    }
    tmp->kind = is_RFKeyVal;
    tmp->u.rFKeyVal_.id_ = p1;
    tmp->u.rFKeyVal_.exp_ = p2;
    return tmp;
}

/********************   RFSpread    ********************/

RecordField make_RFSpread(Exp p1)
{
    RecordField tmp = (RecordField) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RFSpread!\n");
        exit(1);
    }
    tmp->kind = is_RFSpread;
    tmp->u.rFSpread_.exp_ = p1;
    return tmp;
}

/********************   PId    ********************/

Param make_PId(Id p1)
{
    Param tmp = (Param) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating PId!\n");
        exit(1);
    }
    tmp->kind = is_PId;
    tmp->u.pId_.id_ = p1;
    return tmp;
}

/********************   LIExpr    ********************/

ListItem make_LIExpr(Exp p1)
{
    ListItem tmp = (ListItem) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LIExpr!\n");
        exit(1);
    }
    tmp->kind = is_LIExpr;
    tmp->u.lIExpr_.exp_ = p1;
    return tmp;
}

/********************   LISpread    ********************/

ListItem make_LISpread(Exp p1)
{
    ListItem tmp = (ListItem) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LISpread!\n");
        exit(1);
    }
    tmp->kind = is_LISpread;
    tmp->u.lISpread_.exp_ = p1;
    return tmp;
}

/***************************   Cloning   ******************************/

Program clone_Program(Program p)
{
  switch(p->kind)
  {
  case is_PExps:
    return make_PExps (clone_Exp(p->u.pExps_.exp_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Program!\n");
    exit(1);
  }
}

Exp clone_Exp(Exp p)
{
  switch(p->kind)
  {
  case is_ELet:
    return make_ELet
      ( clone_MatchPattern(p->u.eLet_.matchpattern_)
      , clone_Exp(p->u.eLet_.exp_1)
      , clone_Exp(p->u.eLet_.exp_2)
      );

  case is_EList:
    return make_EList (clone_ListListItem(p->u.eList_.listlistitem_));

  case is_ERecord:
    return make_ERecord (clone_ListRecordField(p->u.eRecord_.listrecordfield_));

  case is_ETagged:
    return make_ETagged
      ( strdup(p->u.eTagged_.tag_)
      , clone_Exp(p->u.eTagged_.exp_)
      );

  case is_ELambda:
    return make_ELambda
      ( clone_ListParam(p->u.eLambda_.listparam_)
      , clone_Exp(p->u.eLambda_.exp_)
      );

  case is_EPerform:
    return make_EPerform (clone_Exp(p->u.ePerform_.exp_));

  case is_EHandle:
    return make_EHandle
      ( strdup(p->u.eHandle_.tag_)
      , clone_Exp(p->u.eHandle_.exp_1)
      , clone_Exp(p->u.eHandle_.exp_2)
      );

  case is_EMatch:
    return make_EMatch
      ( clone_Exp(p->u.eMatch_.exp_)
      , clone_ListMatchItem(p->u.eMatch_.listmatchitem_)
      );

  case is_EApply:
    return make_EApply
      ( clone_Exp(p->u.eApply_.exp_)
      , clone_ListExp(p->u.eApply_.listexp_)
      );

  case is_ESelect:
    return make_ESelect
      ( clone_Exp(p->u.eSelect_.exp_)
      , strdup(p->u.eSelect_.id_)
      );

  case is_EVar:
    return make_EVar (strdup(p->u.eVar_.id_));

  case is_EInt:
    return make_EInt (p->u.eInt_.integer_);

  case is_ENegInt:
    return make_ENegInt (p->u.eNegInt_.integer_);

  case is_EString:
    return make_EString (strdup(p->u.eString_.string_));

  case is_ENamedReference:
    return make_ENamedReference (strdup(p->u.eNamedReference_.namedreference_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Exp!\n");
    exit(1);
  }
}

ListListItem clone_ListListItem(ListListItem listlistitem)
{
  if (listlistitem)
  {
    /* clone of non-empty list */
    return make_ListListItem
      ( clone_ListItem(listlistitem->listitem_)
      , clone_ListListItem(listlistitem->listlistitem_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListRecordField clone_ListRecordField(ListRecordField listrecordfield)
{
  if (listrecordfield)
  {
    /* clone of non-empty list */
    return make_ListRecordField
      ( clone_RecordField(listrecordfield->recordfield_)
      , clone_ListRecordField(listrecordfield->listrecordfield_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListMatchItem clone_ListMatchItem(ListMatchItem listmatchitem)
{
  if (listmatchitem)
  {
    /* clone of non-empty list */
    return make_ListMatchItem
      ( clone_MatchItem(listmatchitem->matchitem_)
      , clone_ListMatchItem(listmatchitem->listmatchitem_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListExp clone_ListExp(ListExp listexp)
{
  if (listexp)
  {
    /* clone of non-empty list */
    return make_ListExp
      ( clone_Exp(listexp->exp_)
      , clone_ListExp(listexp->listexp_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListParam clone_ListParam(ListParam listparam)
{
  if (listparam)
  {
    /* clone of non-empty list */
    return make_ListParam
      ( clone_Param(listparam->param_)
      , clone_ListParam(listparam->listparam_)
      );
  }
  else return NULL; /* clone of empty list */
}

MatchItem clone_MatchItem(MatchItem p)
{
  switch(p->kind)
  {
  case is_MatchItem0:
    return make_MatchItem0
      ( clone_MatchPattern(p->u.matchItem0_.matchpattern_)
      , clone_Exp(p->u.matchItem0_.exp_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning MatchItem!\n");
    exit(1);
  }
}

MatchPattern clone_MatchPattern(MatchPattern p)
{
  switch(p->kind)
  {
  case is_MPTagged:
    return make_MPTagged
      ( strdup(p->u.mPTagged_.tag_)
      , clone_MatchPattern(p->u.mPTagged_.matchpattern_)
      );

  case is_MPRecord:
    return make_MPRecord (clone_ListRecordField(p->u.mPRecord_.listrecordfield_));

  case is_MPId:
    return make_MPId (strdup(p->u.mPId_.id_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning MatchPattern!\n");
    exit(1);
  }
}

RecordField clone_RecordField(RecordField p)
{
  switch(p->kind)
  {
  case is_RFKeyVal:
    return make_RFKeyVal
      ( strdup(p->u.rFKeyVal_.id_)
      , clone_Exp(p->u.rFKeyVal_.exp_)
      );

  case is_RFSpread:
    return make_RFSpread (clone_Exp(p->u.rFSpread_.exp_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning RecordField!\n");
    exit(1);
  }
}

Param clone_Param(Param p)
{
  switch(p->kind)
  {
  case is_PId:
    return make_PId (strdup(p->u.pId_.id_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Param!\n");
    exit(1);
  }
}

ListItem clone_ListItem(ListItem p)
{
  switch(p->kind)
  {
  case is_LIExpr:
    return make_LIExpr (clone_Exp(p->u.lIExpr_.exp_));

  case is_LISpread:
    return make_LISpread (clone_Exp(p->u.lISpread_.exp_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning ListItem!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_Program(Program p)
{
  switch(p->kind)
  {
  case is_PExps:
    free_Exp(p->u.pExps_.exp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Program!\n");
    exit(1);
  }
  free(p);
}

void free_Exp(Exp p)
{
  switch(p->kind)
  {
  case is_ELet:
    free_MatchPattern(p->u.eLet_.matchpattern_);
    free_Exp(p->u.eLet_.exp_1);
    free_Exp(p->u.eLet_.exp_2);
    break;

  case is_EList:
    free_ListListItem(p->u.eList_.listlistitem_);
    break;

  case is_ERecord:
    free_ListRecordField(p->u.eRecord_.listrecordfield_);
    break;

  case is_ETagged:
    free(p->u.eTagged_.tag_);
    free_Exp(p->u.eTagged_.exp_);
    break;

  case is_ELambda:
    free_ListParam(p->u.eLambda_.listparam_);
    free_Exp(p->u.eLambda_.exp_);
    break;

  case is_EPerform:
    free_Exp(p->u.ePerform_.exp_);
    break;

  case is_EHandle:
    free(p->u.eHandle_.tag_);
    free_Exp(p->u.eHandle_.exp_1);
    free_Exp(p->u.eHandle_.exp_2);
    break;

  case is_EMatch:
    free_Exp(p->u.eMatch_.exp_);
    free_ListMatchItem(p->u.eMatch_.listmatchitem_);
    break;

  case is_EApply:
    free_Exp(p->u.eApply_.exp_);
    free_ListExp(p->u.eApply_.listexp_);
    break;

  case is_ESelect:
    free_Exp(p->u.eSelect_.exp_);
    free(p->u.eSelect_.id_);
    break;

  case is_EVar:
    free(p->u.eVar_.id_);
    break;

  case is_EInt:
    break;

  case is_ENegInt:
    break;

  case is_EString:
    free(p->u.eString_.string_);
    break;

  case is_ENamedReference:
    free(p->u.eNamedReference_.namedreference_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Exp!\n");
    exit(1);
  }
  free(p);
}

void free_ListListItem(ListListItem listlistitem)
{
  if (listlistitem)
  {
    free_ListItem(listlistitem->listitem_);
    free_ListListItem(listlistitem->listlistitem_);
    free(listlistitem);
  }
}

void free_ListRecordField(ListRecordField listrecordfield)
{
  if (listrecordfield)
  {
    free_RecordField(listrecordfield->recordfield_);
    free_ListRecordField(listrecordfield->listrecordfield_);
    free(listrecordfield);
  }
}

void free_ListMatchItem(ListMatchItem listmatchitem)
{
  if (listmatchitem)
  {
    free_MatchItem(listmatchitem->matchitem_);
    free_ListMatchItem(listmatchitem->listmatchitem_);
    free(listmatchitem);
  }
}

void free_ListExp(ListExp listexp)
{
  if (listexp)
  {
    free_Exp(listexp->exp_);
    free_ListExp(listexp->listexp_);
    free(listexp);
  }
}

void free_ListParam(ListParam listparam)
{
  if (listparam)
  {
    free_Param(listparam->param_);
    free_ListParam(listparam->listparam_);
    free(listparam);
  }
}

void free_MatchItem(MatchItem p)
{
  switch(p->kind)
  {
  case is_MatchItem0:
    free_MatchPattern(p->u.matchItem0_.matchpattern_);
    free_Exp(p->u.matchItem0_.exp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing MatchItem!\n");
    exit(1);
  }
  free(p);
}

void free_MatchPattern(MatchPattern p)
{
  switch(p->kind)
  {
  case is_MPTagged:
    free(p->u.mPTagged_.tag_);
    free_MatchPattern(p->u.mPTagged_.matchpattern_);
    break;

  case is_MPRecord:
    free_ListRecordField(p->u.mPRecord_.listrecordfield_);
    break;

  case is_MPId:
    free(p->u.mPId_.id_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing MatchPattern!\n");
    exit(1);
  }
  free(p);
}

void free_RecordField(RecordField p)
{
  switch(p->kind)
  {
  case is_RFKeyVal:
    free(p->u.rFKeyVal_.id_);
    free_Exp(p->u.rFKeyVal_.exp_);
    break;

  case is_RFSpread:
    free_Exp(p->u.rFSpread_.exp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RecordField!\n");
    exit(1);
  }
  free(p);
}

void free_Param(Param p)
{
  switch(p->kind)
  {
  case is_PId:
    free(p->u.pId_.id_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Param!\n");
    exit(1);
  }
  free(p);
}

void free_ListItem(ListItem p)
{
  switch(p->kind)
  {
  case is_LIExpr:
    free_Exp(p->u.lIExpr_.exp_);
    break;

  case is_LISpread:
    free_Exp(p->u.lISpread_.exp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ListItem!\n");
    exit(1);
  }
  free(p);
}

